// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {VaultManager} from "./VaultManager.sol";

import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol";
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";
import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol";
import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";

contract USDPLNOracle is FunctionsClient, ConfirmedOwner, AutomationCompatibleInterface {
using FunctionsRequest for FunctionsRequest.Request;
  // State variables to store the last request ID, response, and error
    bytes32 public s_lastRequestId;
    bytes public s_lastResponse;
    bytes public s_lastError;

    // Custom error type
    error UnexpectedRequestID(bytes32 requestId);

  event Response(
        bytes32 indexed requestId,
        uint256 plnUsdRate,
        bytes response,
        bytes err
    );

    uint32 gasLimit = 300000; 
    bytes32 donID;
    uint256 public plnUsdRate;
    uint256 public lastTimeStamp;
    uint256 public interval = 1 days; // 1 hour in seconds

string private source = string(
    abi.encodePacked(
        "const apiResponse = await Functions.makeHttpRequest({ url: \"https://api.nbp.pl/api/exchangerates/rates/a/usd/\" });",
        "if (apiResponse.error) { throw Error(\"Request failed\"); }",
        "const { data } = apiResponse;",
        "return Functions.encodeUint256(Math.round(Number(data.rates[0].mid) * 10000));"
    )
);

mapping(address donID => uint256 subscriptionId) public s_subscriptionIds;

    // Subscription ID for the Chainlink Functions subscription
    uint64 public subscriptionId;

    // Constructor to initialize the contract with the DON ID and set the owner
    // The DON ID is used to identify the Data Oracle Network (DON) for Chainlink Functions
    // The owner is set to the address that deploys the contract


constructor(address router, bytes32 _donID) FunctionsClient(router) ConfirmedOwner(msg.sender) {
    donID = _donID;
    lastTimeStamp = block.timestamp;
}


 function sendRequest(
        uint64 subscriptionId
    ) public onlyOwner returns (bytes32 requestId) {
        FunctionsRequest.Request memory req;
        req.initializeRequestForInlineJavaScript(source); 
        // Send the request and store the request ID
        s_lastRequestId = _sendRequest(
            req.encodeCBOR(),
            subscriptionId,
            gasLimit,
            donID
        );

        return s_lastRequestId;
    }


    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
    }

 function performUpkeep(bytes calldata /* performData */) external override {
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            sendRequest(subscriptionId); // Call the sendRequest function to initiate the request
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }


 function fulfillRequest(
        bytes32 requestId,
        bytes memory response,
        bytes memory err
    ) internal override {
        if (s_lastRequestId != requestId) {
            revert UnexpectedRequestID(requestId); // Check if request IDs match
        }
        // Update the contract's state variables with the response and any errors
        s_lastResponse = response;
        plnUsdRate = abi.decode(response, (uint256));
        s_lastError = err;

        // Emit an event to log the response
        emit Response(requestId, plnUsdRate, s_lastResponse, s_lastError);
    }

function getPLNPrice() public view returns (uint256) {
    return plnUsdRate;
}
}